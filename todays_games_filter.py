#!/usr/bin/env python3
"""
üóìÔ∏è TODAY'S GAMES FILTER - SHOW ONLY TODAY'S DATE GAMES!
Filters all games to show only those happening TODAY (September 19, 2025) - REAL-TIME UPDATE!
üî•üíÄüî• UEFA ZERO FAKE DATA APPROACH IMPLEMENTED! üíÄüî•üíÄ
"""

import re
from datetime import datetime, date
from typing import List, Dict, Any
import logging
import pytz

logger = logging.getLogger(__name__)

class TodaysGamesFilter:
    """üóìÔ∏è Filter to show only games happening TODAY"""
    
    def __init__(self):
        # üá≤üáΩ USE MEXICO CITY TIMEZONE for accurate today's date!
        mexico_tz = pytz.timezone('America/Mexico_City')
        mexico_now = datetime.now(mexico_tz)
        self.today = mexico_now.date()  # Mexico City date
        
        self.today_str_formats = [
            self.today.strftime("%d/%m/%Y"),  # European format (DD/MM/YYYY)
            self.today.strftime("%m/%d/%Y"),  # US format (MM/DD/YYYY)
            self.today.strftime("%Y-%m-%d"),  # ISO format (YYYY-MM-DD)
            self.today.strftime("%d/%m/%Y").lstrip("0"),  # No leading zeros DD/MM/YYYY
            self.today.strftime("%m/%d/%Y").lstrip("0"),  # No leading zeros MM/DD/YYYY
        ]
        logger.info(f"üóìÔ∏è TODAY'S GAMES FILTER: Looking for games on {self.today} ({self.today_str_formats[0]}) [Mexico City timezone]")
    
    def filter_todays_games(self, all_games: List[Dict]) -> List[Dict]:
        """üéØ Filter games to show only TODAY'S games"""
        todays_games = []
        
        for game in all_games:
            if self._is_today_game(game):
                todays_games.append(game)
                logger.info(f"‚úÖ TODAY'S GAME: {game.get('away_team', 'Away')} @ {game.get('home_team', 'Home')} - {game.get('start_time', 'No time')}")
            else:
                logger.debug(f"‚ùå NOT TODAY: {game.get('away_team', 'Away')} @ {game.get('home_team', 'Home')} - {game.get('start_time', 'No time')}")
        
        logger.info(f"üéØ FILTERED RESULTS: {len(todays_games)} games TODAY out of {len(all_games)} total games")
        return todays_games
    
    def _is_today_game(self, game: Dict) -> bool:
        """üîç Check if a game is happening TODAY"""
        
        # Check start_time field first
        start_time = game.get('start_time', '')
        if start_time:
            if self._date_matches_today(start_time):
                return True
        
        # Check date field 
        game_date = game.get('date', '')
        if game_date:
            if self._date_matches_today(game_date):
                return True
        
        # Check if any field contains today's date
        for key, value in game.items():
            if isinstance(value, str) and self._date_matches_today(value):
                return True
        
        # If ESPN data, check if it's from today's ESPN API call
        if game.get('real_espn_data'):
            return True  # ESPN API already filtered for today
            
        # üéØ SPECIAL HANDLING FOR MCP GAMES - they are generated TODAY by MCPs!
        mcp_leagues = ['SERIE_A', 'UEFA', 'BUNDESLIGA', 'EREDIVISIE', 'SUPERLIG', 'COPA_LIBERTADORES', 
                       'COPA_SUDAMERICANA', 'LIGUE1', 'LA_LIGA', 'EPL', 'LIGA_MX', 'SEA_LEAGUE']
        game_sport = game.get('sport', '').upper()
        game_league = game.get('league', '').upper().replace(' ', '_')
        
        if (game_sport in mcp_leagues or game_league in mcp_leagues or 
            'MCP' in game.get('source', '').upper() or 
            'MARKET_EFFICIENCY' in game.get('source', '').upper()):
            logger.info(f"‚úÖ MCP GAME ALLOWED: {game.get('away_team', 'Away')} @ {game.get('home_team', 'Home')} - Generated by MCP TODAY")
            return True  # MCP games are generated for today
            
        # Special handling for SEA League - allow ¬±1 day due to timezone differences
        if game.get('sport') == 'SEA_LEAGUE' or game.get('league') in ['SEA_LEAGUE', 'SEA League']:
            game_date_str = game.get('date', '') or game.get('start_time', '')
            if game_date_str:
                try:
                    # Parse the date
                    dt = datetime.fromisoformat(game_date_str.replace('Z', '+00:00'))
                    game_date = dt.date()
                    today = self.today
                    
                    # Allow games within ¬±1 day for Southeast Asian timezone differences
                    days_diff = abs((game_date - today).days)
                    if days_diff <= 1:
                        return True
                except Exception:
                    pass
        
        return False
    
    def _date_matches_today(self, date_string: str) -> bool:
        """üóìÔ∏è Check if a date string matches today"""
        
        # Check exact matches first
        for today_format in self.today_str_formats:
            if today_format in date_string:
                return True
        
        # Parse various date formats
        date_patterns = [
            r'(\d{1,2})/(\d{1,2})/(\d{4})',  # DD/MM/YYYY or MM/DD/YYYY
            r'(\d{4})-(\d{1,2})-(\d{1,2})',  # YYYY-MM-DD
            r'(\d{1,2})-(\d{1,2})-(\d{4})',  # DD-MM-YYYY or MM-DD-YYYY
        ]
        
        for pattern in date_patterns:
            matches = re.findall(pattern, date_string)
            for match in matches:
                if self._parse_date_match(match):
                    return True
        
        # Check for ISO format with time
        iso_pattern = r'(\d{4}-\d{2}-\d{2})'
        iso_matches = re.findall(iso_pattern, date_string)
        for iso_date in iso_matches:
            try:
                parsed_date = datetime.fromisoformat(iso_date).date()
                if parsed_date == self.today:
                    return True
            except:
                continue
        
        return False
    
    def _parse_date_match(self, match: tuple) -> bool:
        """Parse a date match tuple and check if it's today"""
        try:
            # Try different interpretations of the date
            interpretations = []
            
            if len(match) == 3:
                p1, p2, p3 = match
                
                # If year is in position 1 (YYYY-MM-DD)
                if len(p1) == 4:
                    interpretations.append(date(int(p1), int(p2), int(p3)))
                # If year is in position 3
                elif len(p3) == 4:
                    # Try DD/MM/YYYY
                    interpretations.append(date(int(p3), int(p2), int(p1)))
                    # Try MM/DD/YYYY
                    interpretations.append(date(int(p3), int(p1), int(p2)))
            
            # Check if any interpretation matches today
            for parsed_date in interpretations:
                if parsed_date == self.today:
                    return True
                    
        except (ValueError, TypeError):
            pass
        
        return False
    
    def filter_progol_games_by_date(self, progol_games: List[Dict]) -> Dict[str, List[Dict]]:
        """üé∞ Special PROGOL filtering with proper date parsing"""
        
        midweek_today = []
        fullweek_today = []
        
        for game in progol_games:
            # Enhanced PROGOL date parsing
            if self._is_progol_today_game(game):
                # Classify as midweek or fullweek based on teams or time
                if self._is_midweek_game(game):
                    midweek_today.append(game)
                else:
                    fullweek_today.append(game)
        
        result = {}
        if midweek_today:
            result['PROGOL MID-WEEK'] = midweek_today
        if fullweek_today:
            result['PROGOL FULL-WEEK'] = fullweek_today
            
        logger.info(f"üé∞ PROGOL TODAY: {len(midweek_today)} mid-week, {len(fullweek_today)} full-week games")
        return result
    
    def _is_progol_today_game(self, game: Dict) -> bool:
        """üé∞ Check if PROGOL game is in today's context - SAUCY ENOUGH for multi-date PROGOL!"""
        
        # üî• PROGOL-SPECIFIC: Check within ¬±3 days of today (PROGOL spans multiple dates!)
        # This makes the analyzer "saucy enough" to handle PROGOL's multi-date structure
        
        today = datetime.now().date()
        
        # Look for date in various game fields
        date_fields = ['start_time', 'date', 'game_date', 'match_date']
        
        for field in date_fields:
            if field in game:
                date_value = game[field]
                if isinstance(date_value, str):
                    # Try to parse the date
                    game_date = self._extract_date_from_string(date_value)
                    if game_date:
                        # Check if game is within PROGOL context (¬±3 days)
                        days_difference = abs((game_date - today).days)
                        if days_difference <= 3:  # SAUCY ENOUGH: ¬±3 days for PROGOL
                            logger.info(f"üé∞ PROGOL SAUCY FILTER: {game.get('away_team')} @ {game.get('home_team')} - {days_difference} days from today")
                            return True
        
        # Fallback: if it's a PROGOL game with no clear date, include it
        if game.get('sport') == 'PROGOL':
            logger.info(f"üé∞ PROGOL FALLBACK: Including {game.get('away_team')} @ {game.get('home_team')} - no date but PROGOL sport")
            return True
        
        return False
    
    def _extract_date_from_string(self, date_string: str) -> date:
        """üîç Extract date from string - PROGOL enhanced parsing"""
        
        # Try ISO format first (2025-09-06T20:00:00-06:00)
        iso_pattern = r'(\d{4}-\d{2}-\d{2})'
        iso_match = re.search(iso_pattern, date_string)
        if iso_match:
            try:
                return datetime.fromisoformat(iso_match.group(1)).date()
            except:
                pass
        
        # Try other formats
        date_patterns = [
            r'(\d{1,2})/(\d{1,2})/(\d{4})',  # DD/MM/YYYY or MM/DD/YYYY
            r'(\d{4})-(\d{1,2})-(\d{1,2})',  # YYYY-MM-DD
            r'(\d{1,2})-(\d{1,2})-(\d{4})',  # DD-MM-YYYY or MM-DD-YYYY
        ]
        
        for pattern in date_patterns:
            matches = re.findall(pattern, date_string)
            for match in matches:
                try_date = self._parse_date_match_to_date(match)
                if try_date:
                    return try_date
        
        return None
    
    def _parse_date_match_to_date(self, match: tuple) -> date:
        """Parse a date match tuple to actual date object"""
        try:
            if len(match) == 3:
                p1, p2, p3 = match
                
                # If year is in position 1 (YYYY-MM-DD)
                if len(p1) == 4:
                    return date(int(p1), int(p2), int(p3))
                # If year is in position 3, try DD/MM/YYYY first
                elif len(p3) == 4:
                    return date(int(p3), int(p2), int(p1))
        except (ValueError, TypeError):
            pass
        
        return None
    
    def _is_midweek_game(self, game: Dict) -> bool:
        """üé∞ Classify PROGOL game as midweek or fullweek"""
        
        # Simple heuristic: international games are usually midweek
        teams = [game.get('home_team', ''), game.get('away_team', '')]
        
        international_indicators = [
            'M√©xico', 'M√âXICO', 'Mexico',
            'Jap√≥n', 'JAP√ìN', 'Japan', 
            'E.U.A.', 'USA', 'Estados Unidos',
            'Corea', 'COREA', 'Korea',
            'Espa√±a', 'Spain', 'Turqu√≠a', 'Turkey',
            'Italia', 'Italy', 'Israel',
            'Hungr√≠a', 'Hungary', 'Irlanda', 'Ireland',
            'Grecia', 'Greece', 'Dinamarca', 'Denmark'
        ]
        
        for team in teams:
            for indicator in international_indicators:
                if indicator in team:
                    return True  # International = midweek
        
        return False  # Club games = fullweek

# Helper function for direct use
def filter_games_for_today(games: List[Dict]) -> List[Dict]:
    """üéØ Direct function to filter games for today"""
    filter_engine = TodaysGamesFilter()
    return filter_engine.filter_todays_games(games)

def filter_progol_for_today(progol_games: List[Dict]) -> Dict[str, List[Dict]]:
    """üé∞ Direct function to filter PROGOL games for today"""
    filter_engine = TodaysGamesFilter()
    return filter_engine.filter_progol_games_by_date(progol_games)

if __name__ == "__main__":
    # Test the filter
    test_games = [
        {
            'home_team': 'Monterrey F.',
            'away_team': 'Tigres F.',
            'start_time': '07/09/2025, 17:00',
            'venue': 'Estadio BBVA'
        },
        {
            'home_team': 'M√âXICO',
            'away_team': 'Jap√≥n',
            'start_time': '06/09/2025, 20:00',  # Yesterday
            'venue': 'Estadio Azteca'
        },
        {
            'home_team': 'Austin',
            'away_team': 'Kansas City',
            'start_time': '07/09/2025, 17:00',  # Today
            'venue': 'Q2 Stadium'
        }
    ]
    
    print("üóìÔ∏è Testing TODAY'S GAMES FILTER...")
    filtered = filter_games_for_today(test_games)
    
    print(f"\nFiltered {len(filtered)} games for today:")
    for game in filtered:
        print(f"  ‚úÖ {game['away_team']} @ {game['home_team']} - {game['start_time']}")